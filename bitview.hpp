#pragma once
#include "bitptr.hpp"

#include <iostream>
#include <cassert>
#include <vector>
#include <string_view>
#include <span>

using flat_table = char const* const*;
[[nodiscard]] flat_table flatten( std::span< const std::string > strings );

// Returns a table of base-10 strings representing the value of 
// each power of 2 up to bitlen as indexed by the table. All memory 
// for the table and strings is jointly allocated. The largest table 
// generated by this function is cached for future calls. When this 
// function caches a larger table the previous table is invalidated, 
// therefore the return value of this function should not be stored.
flat_table int_powers( size_t bitlen )
{
    static std::vector< std::string > powers { "1" };
    static flat_table compact_powers = flatten( powers );
    static size_t maxlen = 1;

    if ( bitlen > maxlen )
    {
        powers.resize( bitlen );
        for ( size_t i = maxlen; i < bitlen; ++i )
            powers[ i ] = lex_mul2( powers[ i - 1 ] );
        maxlen = bitlen;

        delete[] compact_powers;
        compact_powers = flatten( powers );
    }
    return compact_powers;
}

// Jointly allocates an array of c-string pointers (array of char*)
// and the text that they point to (array of char), i.e.
// new struct { char* table[ size ]; char text[ total_length ]; };
flat_table flatten( std::span< const std::string > strings )
{
    // Determine how much memory is needed.
    size_t table_size = strings.size() * sizeof( char* );
    size_t total_size = table_size + strings.size(); // plus '\0' for each string
    for ( std::string_view str : strings )
        total_size += str.length();

    // Do the joint allocation.
    char* allocation = new char[ total_size ];
    char** table = (char**) allocation;
    char* text = allocation + table_size;

    // Fill in the table and text data.
    for ( std::string_view str : strings )
    {
        *table++ = text;
        for ( char c : str )
            *text++ = c;
        *text++ = '\0';
    }

    return flat_table( allocation );
}

bool in_place_lex_div2( std::span< char > str )
{
    char carry = 0;
    for ( size_t i = 0; i < str.size(); ++i )
    {
        char x = str[ i ] - '0';
        x += carry * 10;
        carry = x & 1;
        x /= 2;
        str[ i ] = x + '0';
    }
    return carry != 0;
}

bool lex_eq_0( std::string_view num )
{
    return num.find_first_not_of( '0' ) == std::string::npos;
}

class bigint;

class bitview
{
    bitptr ptr = nullptr;
    size_t len = 0;

public:

    bitview() = default;
    bitview( const bitview& ) = default;

    bitview( void* ptr, size_t off, size_t len )
        : ptr { ptr, off }, len { len }
    {
    }

    bitview( bitptr ptr, size_t len )
        : ptr { ptr }, len { len }
    {
    }

    bitview( bitptr first, bitptr last )
        : bitview( first, last - first )
    {
        assert( first <= last );
    }

    using iterator = bitptr;

    iterator begin() const { return ptr; }
    iterator end() const { return ptr + len; }
    size_t size() const { return len; }

    bitref operator []( size_t pos ) const
    {
        assert( pos < len );
        return ptr[ pos ];
    }

    friend bitview add( bitview a, bitview b, bitview c );
    friend bitview sub( bitview a, bitview b, bitview c );
    friend bitview mul( bitview a, bitview b, bitview c );
    friend void divmod( bitview a, bitview b, bitview c, bitview d );
    friend std::strong_ordering compare( bitview a, bitview b );

    friend bitview bit_or( bitview a, bitview b, bitview c );
    friend bitview bit_and( bitview a, bitview b, bitview c );
    friend bitview bit_xor( bitview a, bitview b, bitview c );
    friend bitview flip( bitview a, bitview c );

    friend size_t from_string( std::string_view, bitview );
    friend std::string to_string( bitview, flat_table );
    friend std::string to_string( bitview bits ) {
        return to_string( bits, int_powers( bits.len ) );
    }

    friend std::ostream& operator <<( std::ostream& os, bitview a )
    {
        return os << std::hex << a.ptr.ptr << '.' << a.ptr.bit
            << std::dec << '[' << a.len << ']';
    }

    friend class bigint;

    bool highest_set_bit( size_t& pos ) const;
};


ubyte unmasked_byte_n( bitview x, size_t n )
{
    return *(uint*) x[ n * 8 ].ptr >> x[ n * 8 ].bit;
}

ubyte byte_n( bitview x, size_t n )
{
    return unmasked_byte_n( x, n )
        & ~(~0u << x.size() - n);
}

#define B2B_TIGHT( BITS ) ((BITS + 7) / 8)
#define B2B_LOOSE( BITS ) (BITS / 8 + 1)

bool bitview::highest_set_bit( size_t& pos ) const
{
    for ( int i = (len + 7) / 8 - 1; i >= 0; --i )
    {
        unsigned long off = 0;
        if ( _BitScanReverse( &off, byte_n( *this, i ) ) )
        {
            pos = i * 8 + off;
            return true;
        }
    }
    return false;
}

void set_unmasked_byte_n( bitview x, ubyte y, size_t n )
{
    size_t off = x[ n * 8 ].bit;
    ushort a = ushort( y ) << off;
    ushort& b = *(ushort*) x[ n * 8 ].ptr;
    ushort mask = ~(ushort( ~'\0' ) << off);
    b = b & mask | a;
}

void set_byte_n( bitview x, ubyte y, size_t n )
{
    size_t off = x[ n * 8 ].bit;
    ubyte bmask = ~(ubyte( ~'\0' ) << x.size() - n);
    ushort mask = ~(ushort( bmask ) << off);
    ushort a = ushort( y & bmask ) << off;
    ushort& b = *(ushort*) x[ n * 8 ].ptr;
    b = b & mask | a;
}


// I: input bitview
// O: output byte-array allocated on the stack
// S: size in bits to allocate
#define INLINE_BITVIEW( I, O, S )                   \
const auto O = I.ptr.bit == 0 && I.len >= S         \
    ? (ubyte*) I.ptr.ptr                            \
    : (ubyte*) alloca( S / 8 + 1 );                 \
if ( O != (ubyte*) I.ptr.ptr ) {                    \
    for ( size_t n = 0; n < (I.len + 7) / 8; ++n )  \
        O[ n ] = unmasked_byte_n( I, n );           \
    O[ I.len / 8 ] &= ~(~0u << I.len % 8);          \
    for ( size_t m = I.len / 8; m < S / 8; ++m )    \
        O[ m ] = 0;                                 \
};

// in: input byte-array, size is assumed to match `out`
// out: output bitview
void outline_bitview( const ubyte* in, bitview out )
{
    if ( out.begin().bit != 0 || in != (const ubyte*) out.begin().ptr )
    {
        int n = 0;
        for (; n + 1 < (out.size() + 7) / 8; ++n )
            set_unmasked_byte_n( out, in[ n ], n );
        set_byte_n( out, in[ n ], n );
    }
}

// a + b = c
bitview add( bitview a, bitview b, bitview c )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for ( uint carry = 0; n < (maxlen + 7) / 8; ++n )
    {
        uint sum = (uint) A[ n ] + B[ n ] + carry;
        C[ n ] = (ubyte) sum;
        carry = sum >> 8;
    }
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}

// a - b = c
bitview sub( bitview a, bitview b, bitview c )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for ( int carry = 0; n < (maxlen + 7) / 8; ++n )
    {
        int sum = (int) A[ n ] - B[ n ] - carry;
        C[ n ] = (ubyte) sum;
        carry = sum < 0;
    }
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}

bitview increment( bitview x, bool one = 1 )
{
    return add( x, bitview( &one, 0, 1 ), x );
}

bitview decrement( bitview x, bool one = 1 )
{
    return sub( x, bitview( &one, 0, 1 ), x );
}

// a * b = c
bitview mul( bitview a, bitview b, bitview c )
{
    const size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    const size_t lenbyte = (maxlen + 7) / 8;

    // Array of inline bitviews representing the products
    const auto products = (ubyte**) alloca( lenbyte * sizeof( ubyte* ) );
    for ( int i = 0; i < lenbyte; ++i )
        products[ i ] = (ubyte*) alloca( lenbyte );

    const size_t szcarry = (lenbyte + 1) * sizeof( ushort );
    const auto carry = (ushort*) alloca( szcarry );

    // Multiply each sub-coefficient
    for ( int i = 0; i < lenbyte; ++i )
    {
        memset( carry, 0, szcarry );
        for ( int j = 0; j < lenbyte; ++j )
            carry[ j ] = (ushort) A[ i ] * B[ j ];

        // Sum sub-products into the product
        for ( int k = 0; k < lenbyte; ++k )
        {
            products[ i ][ k ] = (ubyte) carry[ k ];
            carry[ k + 1 ] += ubyte( carry[ k ] >> 8 );       
        }
    }

    // The output variable
    const auto C = (ubyte*) alloca( c.len / 8 + 1 );
    memset( C, 0, c.len / 8 + 1 );
    // Sum products into the output
    for ( int i = 0; i < lenbyte; ++i )
    {
        ushort carry = 0;
        for ( int n = i; n < lenbyte; ++n )
        {
            ushort x = carry + C[ n ] + products[ i ][ n - i ];
            C[ n ] = (ubyte) x;
            carry = ubyte( x >> 8 );
        }
    }

    outline_bitview( C, c );
    return c;
}

// a /% b = c, d
void divmod( bitview a, bitview b, bitview c, bitview d )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( d.len == maxlen && c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );
    auto D = (ubyte*) alloca( d.len / 8 + 1 );
    std::memset( C, 0, c.len / 8 + 1 );

    // if A is larger than B
    if ( strncmp( (char*) A, (char*) B, maxlen ) >= 0 ) do
    {
        // subtract B
        int carry = 0;
        for ( int n = 0; n < (maxlen + 7) / 8; ++n )
        {
            int sum = (int) A[ n ] - B[ n ] - carry;
            D[ n ] = (ubyte) sum;
            carry = sum < 0;
        }
        increment( bitview( C, 0, c.len ) );
        // while D is larger than B
    } while ( strncmp( (char*) D, (char*) B, maxlen ) >= 0 );

    else for ( int n = 0; n < (maxlen + 7) / 8; ++n )
        D[ n ] = A[ n ];

    outline_bitview( C, c );
    outline_bitview( D, d );
}

// a / b = c
bitview div( bitview a, bitview b, bitview c )
{
    const auto D = (ubyte*) alloca( c.size() / 8 + 1 );
    divmod( a, b, c, bitview( D, 0, c.size() ) );
    return c;
}

// a % b = c
bitview mod( bitview a, bitview b, bitview d )
{
    const auto C = (ubyte*) alloca( d.size() / 8 + 1 );
    divmod( a, b, bitview( C, 0, d.size() ), d );
    return d;
}

// a | b = c
bitview bit_or( bitview a, bitview b, bitview c )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for (; n < (maxlen + 7) / 8; ++n )
        C[ n ] = A[ n ] | B[ n ];
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}

// a & b | c
bitview bit_and( bitview a, bitview b, bitview c )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for (; n < (maxlen + 7) / 8; ++n )
        C[ n ] = A[ n ] & B[ n ];
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}

// a ^ b = c
bitview bit_xor( bitview a, bitview b, bitview c )
{
    size_t maxlen = std::max( a.len, b.len );
    assert( c.len >= maxlen );

    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for (; n < (maxlen + 7) / 8; ++n )
        C[ n ] = A[ n ] ^ B[ n ];
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}

std::strong_ordering compare( bitview a, bitview b )
{
    size_t maxlen = std::max( a.len, b.len );
    INLINE_BITVIEW( a, A, maxlen );
    INLINE_BITVIEW( b, B, maxlen );

    for ( int i = maxlen - 1; i >= 0; --i )
        if ( A[ i ] > B[ i ] ) return std::strong_ordering::greater;
        else if ( A[ i ] < B[ i ] ) return std::strong_ordering::less;
    return std::strong_ordering::equal;
    //return std::strncmp( (char*) A, (char*) B, maxlen );
}

// ~a = c
bitview flip( bitview a, bitview c )
{
    assert( c.len >= a.len );
    INLINE_BITVIEW( a, A, a.len );
    auto C = (ubyte*) alloca( c.len / 8 + 1 );

    int n = 0;
    for (; n < (a.len + 7) / 8; ++n )
        C[ n ] = ~A[ n ];
    while ( n < c.len / 8 + 1 )
        C[ n++ ] = 0;

    outline_bitview( C, c );
    return c;
}


std::string to_string( bitview bits, flat_table powers )
{
    std::string num = "0";
    for ( size_t i = 0; i < bits.len; ++i )
        if ( bits[ i ] )
            num = lex_add( num, powers[ i ] );
    return ltrim( num, '0' );
}

size_t from_string( std::string_view str, bitview bits )
{
    bool negative = str[ 0 ] == '-';
    std::string num( str.substr( negative || str[ 0 ] == '+' ) );

    size_t bit = 0;
    do bits[ bit++ ] = negative != in_place_lex_div2( num );
    while ( !lex_eq_0( num ) && bit < bits.len );
    increment( bits, negative );

    if ( !lex_eq_0( num ) )
        std::cerr << "error: from_string(\"" << str << "\", {" << bits << "}); "
            "`str` was too large to be held by `bits`" << std::endl;
    return bit;

    //bool odd = in_place_lex_div2( num );
    //bits[ bit ] = (!negative && odd) || (negative && !odd);
}


void print( bitview bits, std::ostream& os = std::cout )
{
    for ( bool bit : bits )
        os << bit[ "01" ];
    os << ' ' << (int) byte_n( bits, 0 );
}

int main2()
{
    using std::cout;
    using std::endl;

    long long n = 5;
    bitview bits1( &n, 0, 8 ),
        bits2( &n, 1, 8 );

    print( bits1 ); cout << endl;
    print( bits2 ); cout << endl;

    add( bits1, bits2, bits1 );
    print( bits1 ); cout << endl;
    print( bits2 ); cout << endl;

    mul( bits1, bits2, bits1 );
    print( bits1 ); cout << endl;
    print( bits2 ); cout << endl;

    sub( bits1, bits2, bits1 );
    print( bits1 ); cout << endl;
    print( bits2 ); cout << endl;
    cout << endl;

    long long a = 1000;
    long long b = 450;

    bitview bva( &a, 0, 32 );
    bitview bvb( &b, 0, 32 );

    print( bva ); cout << a << endl;
    print( bvb ); cout << b << endl;

    add( bva, bvb, bva );
    print( bva ); cout << a << endl;
    print( bvb ); cout << b << endl;

    sub( bva, bvb, bva );
    print( bva ); cout << a << endl;
    print( bvb ); cout << b << endl;

    sub( bva, bvb, bva );
    print( bva ); cout << a << endl;
    print( bvb ); cout << b << endl;

    cout << int( n );

    return 0;
}


class bigint : std::string
{
    explicit bigint( size_t bits )
        : std::string( (bits + 7) / 8, '\0' )
    {
    }

    bitview bits() const
    {
        return bitview( (char*) data(), 0, size() * 8 );
    }

    operator bitview() const
    {
        return bits();
    }

    bool is_negative() const
    {
        return bits()[ bits().len - 1 ];
    }

    void shrink()
    {
        char leading = is_negative() ? ~'\0' : '\0';
        if ( size_t end = find_last_not_of( leading ) + 1 )
            resize( end );
    }

public:

    bigint() : bigint( 1ull ) {}
    bigint( const bigint& ) = default;

    bigint( int num )
        : bigint( sizeof( int ) * 8 )
    {
        std::memcpy( data(), &num, size() );
    }

    bigint( long long num )
        : bigint( sizeof( long long ) * 8 )
    {
        std::memcpy( data(), &num, size() );
    }

    explicit bigint( std::string_view str )
        : bigint( (str.size() + 1) * 4 ) //(... / 2) * 8
    {
        resize( (from_string( str, bits() ) + 7) / 8 );
    }

    explicit operator std::string() const
    {
        return to_string( bits() );
    }

    friend bigint operator +( const bigint& a, const bigint& b )
    {
        bigint c( 1 + std::max( a.bits().size(), b.bits().size() ) );
        add( a, b, c );
        c.shrink();
        return c;
    }

    friend bigint operator -( const bigint& a, const bigint& b )
    {
        bigint c( 1 + std::max( a.bits().size(), b.bits().size() ) );
        sub( a, b, c );
        c.shrink();
        return c;
    }

    friend bigint operator *( const bigint& a, const bigint& b )
    {
        bigint c( 2 * std::max( a.bits().size(), b.bits().size() ) );
        mul( a, b, c );
        c.shrink();
        return c;
    }

    friend bigint operator /( const bigint& a, const bigint& b )
    {
        bigint c( std::max( a.bits().size(), b.bits().size() ) );
        div( a, b, c );
        c.shrink();
        return c;
    }

    friend bigint operator %( const bigint& a, const bigint& b )
    {
        bigint d( std::max( a.bits().size(), b.bits().size() ) );
        mod( a, b, d );
        d.shrink();
        return d;
    }

    friend bigint operator |( const bigint& a, const bigint& b )
    {
        bigint c( std::max( a.bits().size(), b.bits().size() ) );
        bit_or( a, b, c );
        return c;
    }

    friend bigint operator &( const bigint& a, const bigint& b )
    {
        bigint c( std::max( a.bits().size(), b.bits().size() ) );
        bit_and( a, b, c );
        return c;
    }

    friend bigint operator ^( const bigint& a, const bigint& b )
    {
        bigint c( std::max( a.bits().size(), b.bits().size() ) );
        bit_xor( a, b, c );
        return c;
    }

    friend auto operator <=>( const bigint& a, const bigint& b )
    {
        return ::compare( a, b );
    }

    bigint& operator +=( const bigint& x ) { return *this = *this + x; }
    bigint& operator -=( const bigint& x ) { return *this = *this - x; }
    
    bigint& operator *=( const bigint& x ) { return *this = *this * x; }
    bigint& operator /=( const bigint& x ) { return *this = *this / x; }
    bigint& operator %=( const bigint& x ) { return *this = *this % x; }

    bigint& operator |=( const bigint& x ) { return *this = *this | x; }
    bigint& operator &=( const bigint& x ) { return *this = *this & x; }
    bigint& operator ^=( const bigint& x ) { return *this = *this ^ x; }

    bigint operator -() const { return operator ~() + 1; }
    bigint operator +() const { return *this; }
    bigint operator ~() const
    {
        bigint x( bits().size() );
        flip( bits(), x );
        return x;
    }

};
